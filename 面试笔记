http请求： 
    1. 因为是无状态协议  所以要需要拿着cookie才知道你是'老用户'
    2. tcp连接,会与ip连接 TCP/IP -> 发送请求 -> 接收请求 -> 发送数据 -> 断开tcp连接
    3. 有自己对状态码 1（已经接受正在处理）  2（成功） 3（重定向） 4（客户端错误） 5（服务端错误）
    3. 优化http请求的方案
        TCP复用，多个http请求通过一个tcp连接进行请求；
        将经常用到的内容缓存起来；
        将文本内容进行压缩，减少带宽
        tcp缓冲技术
        ssl协议对http协议进行加密并加速

promise原理：
    1.有一个队列，通过then方法注册回调函数，放入队列，当请求成功对时候，调用resolve函数，将队列里面的回调函数一一执行
    2.要在resolve执行之前，必须保证then方法已经注册好所有的回调方法，所以使用setTimeout将resolve函数包一层，通过setTimeout机制，
        将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成.
    3.失败执行reject
    4.可以写成链式

闭包：
    首先说一下这个GC（垃圾回收机制） 函数在执行中 会分配一个空间  执行后会回收这个函数 这就是一个回收机制 闭包里面的变量只要还在用 就不会被回收
    闭包本质 －－ 局部变量利用闭包保存下来 以供后面来用 保存的本质 整个函数封在一个对象里 整个对象就是栈  
            －－  函数作为返回值，函数作为参数传递

    1.底层：栈   
        计算机执行函数的时候 每调一次函数 会替这个函数分配一个空间 这空间叫栈 所有的变量都在这个栈里面跑  函数结束的时候也会回收  
        闭包可以做到函数执行完了 栈也不回收 这就叫闭包
    2.高层：把函数当成对象处理  函数调用的时候就会创建一个对象 
    3.缺点：不回收会造成性能问题，解决方法：在退出函数之前，将不使用的局部变量全部删除。


原型：
    1.每一个函数function都有一个prototype属性 是一个对象 所有属性的集合
    2.protype有一个constructor属性 指向这个函数的本身
    3.可以在prototype里面增加自己的属性  默认方法有hasOwnProperty,isPrototypeOf等
    4.   fn=new Fn();  fn 可以调用 Fn里面的prototype属性跟方法 
    5. 每个被new出来的fn 都有一个__proto__对隐式原型  fn.__proto__ === Fn.prototype;
    6.Object.prototype的__proto__ 指向null 
    7.Object.__proto__ === Function.prototype 因为Object是被Function创造出来的
    8. Object instanceof Function  true
        Function instanceof Object  true
        Function instanceof Function  true
    9.  arr instanceof Array //true  可以判断是否为数组     fn instanceof Fn    //true

原型链：
    1.继承     
    2.访问一个对象属性时候，先查找自身是否有这个属性，没有沿着__proto__这条链向上找，这就是原型链
    3.hasOwnProperty 是否
作用域链：
    1. 全局作用域   函数内部作用域  es6用let解决链这个问题 块级作用域
    2. 要知道一个作用域下面的值是多少，要联系上下文才知道

call跟apply区别：
    sub.apply(add,arguments);
    sub.apply(add,[4,2]);
    sub.apply(call,4,2);



h5缓存:
    1.
        h5的离线缓存：  
        <html manifest = "cache.manifest">    cache.mainifest  文件  
    2.
        cookies:    4K   浏览器与服务器之间来回传递
        sessionStoreage:    5M   关闭浏览器之后自动销毁
        localStorage:       5M   除非手动删除  不然永远存在
        localStorage 设计方案：
            1.不同域名都有自己的5M空间，从其他域名的地方来跨域 使用postMessage和iframe来跨域
            2.不同业务块没有耦合的话 自己业务上加一个前缀，删除别人所有localStorage
    3.
        setItem getItem  removeItem方法    

    

    
伪数组变成真数组:
    Array.prototype.slice.call(arguments);



数组操作：
    入栈push()、 出栈pop()；

    删除
        pop()方法，删除并返回数组的最后一个元素 
        shift()方法，删除并返回数组的第一个元素    
    增加：        
    　　 unshift()方法，它能在数组首端添加任意个项并返回新数组的长度
        push() 

　　 



es6：
    let    const    ...array     ()=>{}       let {a,b}={a:1,b=2}       
    `我是字符串模板，里面可以放${price}`        arr.map({})  arr.froEach({})  arr.filter({})
 

gulp webback的区别：  webpack.config.js 第17节课的文件
    webpack:打包工具  把项目中文件打包成一个或多个文件 实现模块化
        1.打包工具   
        2.模块化识别 
        3.编译模块工具 
    gulp：是工具链  构建工具  对文件进行压缩编译 实现自动化
        1.构建项目工具
        2.模块化
        3.提高工作效率

 
vue vue-cli  vuex   vue2-animate
    new Vue({})：
        el template components props data create  methods computed
    vuex:  
        可以在modules里定义多个store   state  mutations actions getters  映射方法    
    vuex辅助方法： 
        可以把store对象里面的 state actions getters 映射到 vue组件里面直接使用
        mapState        state -> computed方法里       
        mapActions      actions -> methods方法里
        mapGetter       getters -> computed方法里



nodejs：
    环境变量：
        process.env.NODE_ENV === 'production'
        process.env.NODE_ENV === 'development'


ajax:
    1. 针对mvc变成与mvvm不符
    2. 需要引入jq 不方便
fetch:
    1. fetch默认不会带cookie，需要添加配置项 
    2. 只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
    3. fetch没有办法原生监测请求的进度
axios:
    1. 从nodejs创建http请求
    2. 支持Promise的api
    3. 提供一些并发请求接口
    4. 安全 支持防止 CSRF/XSRF




性能：
    1. 减少http请求
    2. 页面打开速度
    3. 执行效率
安全：
    1. XSS
        1.跨站脚本攻击
        2.往Web页面里插入恶意Script代码
        3.比如盗取用户的cookie。
        4.可插入执行脚本的漏洞，比如某段编辑内容，如果不处理用户的输入就直接存储到数据库中
    2. CSRF
        1.跨站请求伪造
        2.比如目标网站的删除文章功能接受到来自恶意网站客户端发出的删除文章请求
        3.在恶意网站上先构建一个GET请求 ,欺骗目标网站用户访问该恶意网站，则在访问时会发起对应请求（并附带对应的Cookie等用户识别信息），此时攻击也会发生

加密:
    1. md5.js
    2. base64加密
    3. sha1.js
    4. jsencrypt.js
    5. 最可靠的加密是前端js的md5+salt加密（非对称加密）
        md5只能加密不能解密  ＋  为用户生成Salt值； 与密码进行连接 连接后散列 得到hash值  hash与salt都存入数据库 
        登录时 用户输入的密码跟数据库的salt值进行散列 跟数据库的hash值进行对比 一致就成功





跨域：      https://www.cnblogs.com/roam/p/7520433.html
    1.) 资源跳转： A链接、重定向、表单提交
    2.) 资源嵌入： <link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件外链
    3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
    解决方法：
    1、 通过jsonp跨域
                <script>
                    var script = document.createElement('script');
                    script.type = 'text/javascript';

                    // 传参并指定回调执行函数为onBack
                    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';
                    document.head.appendChild(script);

                    // 回调执行函数
                    function onBack(res) {
                        alert(JSON.stringify(res));
                    }
                </script>
    2、 document.domain + iframe跨域
    3、 location.hash + iframe
    4、 window.name + iframe跨域
    5、 postMessage跨域
    6、 跨域资源共享（CORS）
    7、 nginx代理跨域
    8、 nodejs中间件代理跨域
    9、 WebSocket协议跨域
        



简历可以写：  
    async 异步可以当同步写
    vuex
    ES6的怎么实现类还要类的继承         02课es6的面向对象
    webpack的了解                    见17课的webpack.config.js 
    

 

 
 
    https://zhuanlan.zhihu.com/p/26540168
    箭头函数不能使用的情况：
        定义对象方法
        回调函数
        原型函数
        定义构造函数
    箭头函数什么时候可以省略括号：
        无行参的时候    
 

    sass less 区别
        less @符号表示变量  sass $符号表示变量
        sass支持if else 语句控制

 

谈谈webpack：
优点：WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。
它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。
对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后生成了优化且合并后的静态资源。
  好处：
  1.loader处理各种静态文件
  2.webpack上commonjs写的  AMD/CMD 的支持也很全面
  3.对es6语法做了兼容
  4.可以将代码切成块（chunk），实现按需加载，降低初始化时间
  5.拥有强大的plugin 大部分内部插件 用起来比较灵活
  6.有独立的配置文件webpack.config.js


   

 














－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
react部分：


1. React有props和state:
    props意味着父级分发下来的属性，
    state意味着组件内部可以自行管理的状态，
    并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。理解这个是理解React和Redux的前提。


2. 一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。


3. 子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。


4. 为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。


5. 为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。
让我们回来看看重现上面结构的需求：
    a. 需要回调通知state (等同于回调参数) -> action
    b. 需要根据回调处理 (等同于父级方法) -> reducer
    c. 需要state (等同于总状态) -> store


对Redux来说只有这三个要素：
    a. action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑。
    b. reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。
    c. store负责存储状态并可以被react api回调，发布action.当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。很多人其实看懂了redux卡在这里。


    a. Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。   

    b. connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：

        mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。

        mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。
        这也是为什么要科里化的原因。做好以上流程Redux和React就可以工作了。


    简单地说就是：
    1.顶层分发状态，让React组件被动地渲染。
    2.监听事件，事件有权利回到所有状态顶层影响状态。





    dva－cli框架 namespace state effect reducer各表示什么



    redux知识点:
        const actions = this.props.userInfoActions; //获取redux中的action
        let userInfo = this.props.userInfo; //获取redux的user信息
        userInfo.username = username;   //修改user信息
        actions.updata(userInfo);      //执行action里面的updata函数  更新userInfo里面的username
        mapStateToProps(state){
            return (
                userInfo:state.userInfo
            )
        }
        mapDispatchToProps(dispatch){
            return (
                userInfoActions:bindActionCreators(userInfoActionForm)
            )
        }


    router知识点:https://segmentfault.com/a/1190000012258651  路由4
        <Router history={this.props.history}>
            <Route path="/" component={App}>
                <IndexRoute component={Home}>
                <Route path="/city" component={City}>
                <Route path="/login(/:router)" component={Login}>
                <Route path="/search/:category(/:keyWord)" component={Search}>
                <Route path="datail/:id" component{Detail}>
                <Route path="*" component="{NotFind}">
            </Route>
        </Router>


        <Route path="/login(/:router)" component={Login}>解释：
        点击一些操作的时候需要登录状态，rudex中如果没用用户登录的状态，就带着本页面的url跳转到登录页面，登录以后根据url上到参数再跳回本页面
        跳转的登陆页面的时候会带上页面的url，通过router获取
        const params = this.props.params; /／获取URL中所有的字段
        const router = params.router;   // 获取url中的router字段
        if(router){
            history.push(router);
        }

        <Redirect from="/" to="/home"></Redirect>    重定向

